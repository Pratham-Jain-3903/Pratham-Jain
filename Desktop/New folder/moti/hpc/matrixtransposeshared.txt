#include <stdio.h>
#include <stdlib.h>

#define TILE_DIM 16
#define BLOCK_ROWS 16

__global__ void transpose(float *in, float *out, int width, int height)
{
    __shared__ float tile[TILE_DIM][TILE_DIM+1];
    
    int xIndex = blockIdx.x * TILE_DIM + threadIdx.x;
    int yIndex = blockIdx.y * TILE_DIM + threadIdx.y;
    int index_in = yIndex * width + xIndex;
    
    xIndex = blockIdx.y * TILE_DIM + threadIdx.x;
    yIndex = blockIdx.x * TILE_DIM + threadIdx.y;
    int index_out = yIndex * height + xIndex;
    
    for (int i = 0; i < TILE_DIM; i += BLOCK_ROWS)
    {
        tile[threadIdx.y+i][threadIdx.x] = in[index_in+i*width];
    }
    
    __syncthreads();
    
    for (int i = 0; i < TILE_DIM; i += BLOCK_ROWS)
    {
        out[index_out+i*height] = tile[threadIdx.x][threadIdx.y+i];
    }
}

int main()
{
    int width = 1024;
    int height = 1024;
    int size = width * height * sizeof(float);
    
    float *in = (float *) malloc(size);
    float *out = (float *) malloc(size);
    
    float *d_in, *d_out;
    cudaMalloc((void **) &d_in, size);
    cudaMalloc((void **) &d_out, size);
    
    for (int i = 0; i < width * height; i++)
    {
        in[i] = i;
    }
    
    cudaMemcpy(d_in, in, size, cudaMemcpyHostToDevice);
    
    dim3 dimGrid(width/TILE_DIM, height/TILE_DIM, 1);
    dim3 dimBlock(TILE_DIM, BLOCK_ROWS, 1);
    
    transpose<<<dimGrid, dimBlock>>>(d_in, d_out, width, height);
    
    cudaMemcpy(out, d_out, size, cudaMemcpyDeviceToHost);
    
    for (int i = 0; i < height; i++)
    {
        for (int j = 0; j < width; j++)
        {
            printf("%f ", out[i*width+j]);
        }
        printf("\n");
    }
    
    cudaFree(d_in);
    cudaFree(d_out);
    free(in);
    free(out);
    
    return 0;
}
