#include <stdio.h>

#define N 1024

__global__ void transpose(int *a, int *b, int n)
{
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    int j = blockIdx.y * blockDim.y + threadIdx.y;
    
    if (i < n && j < n) {
        b[i*n+j] = a[j*n+i];
    }
}

int main()
{
    int a[N*N], b[N*N], c[N*N];
    int *dev_a, *dev_b;
    
    // Initialize input matrix
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            a[i*N+j] = i*N+j;
        }
    }
    
    // Allocate memory on device
    cudaMalloc((void**)&dev_a, N*N*sizeof(int));
    cudaMalloc((void**)&dev_b, N*N*sizeof(int));
    
    // Copy input matrix to device
    cudaMemcpy(dev_a, a, N*N*sizeof(int), cudaMemcpyHostToDevice);
    
    // Set thread and block sizes
    dim3 threadsPerBlock(16, 16);
    dim3 numBlocks(N/threadsPerBlock.x, N/threadsPerBlock.y);
    
    // Launch kernel
    transpose<<<numBlocks, threadsPerBlock>>>(dev_a, dev_b, N);
    
    // Copy output matrix from device
    cudaMemcpy(b, dev_b, N*N*sizeof(int), cudaMemcpyDeviceToHost);
    
    // Verify transpose
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            c[j*N+i] = a[i*N+j];
        }
    }
    for (int i = 0; i < N*N; i++) {
        if (b[i] != c[i]) {
            printf("Error: transpose incorrect!\n");
            break;
        }
    }
    
    // Free memory on device
    cudaFree(dev_a);
    cudaFree(dev_b);
    
    printf("Transpose correct!\n");
    
    return 0;
}
